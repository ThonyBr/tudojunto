<!DOCTYPE html>
<html lang="pt-BR">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>Jogo de Carro 3D</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background: #111;
    }
    canvas {
      display: block;
    }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.152.2/build/three.min.js"></script>
<script>
  const scene = new THREE.Scene();
  scene.background = new THREE.Color(0x87ceeb);

  const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
  camera.position.set(0, 6, 12);
  camera.lookAt(0,0,0);

  const renderer = new THREE.WebGLRenderer({antialias:true});
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  const light = new THREE.DirectionalLight(0xffffff, 1);
  light.position.set(5,10,5);
  scene.add(light);

  const groundGeo = new THREE.PlaneGeometry(200, 500);
  const groundMat = new THREE.MeshStandardMaterial({color: 0x228B22});
  const ground = new THREE.Mesh(groundGeo, groundMat);
  ground.rotation.x = -Math.PI/2;
  ground.position.y = -0.01;
  scene.add(ground);

  const roadGeometry = new THREE.PlaneGeometry(10, 500);
  const roadMaterial = new THREE.MeshStandardMaterial({color: 0x333333});
  const road = new THREE.Mesh(roadGeometry, roadMaterial);
  road.rotation.x = -Math.PI/2;
  road.position.y = 0;
  scene.add(road);

  const laneMarks = [];
  for (let i=0;i<60;i++){
    const markGeo = new THREE.PlaneGeometry(0.5, 3);
    const markMat = new THREE.MeshStandardMaterial({color:0xffffff});
    const mark = new THREE.Mesh(markGeo,markMat);
    mark.rotation.x = -Math.PI/2;
    mark.position.set(0,0.01,-i*10);
    scene.add(mark);
    laneMarks.push(mark);
  }

  // Carro
  const carGroup = new THREE.Group();
  const bodyGeo = new THREE.BoxGeometry(1.2,0.5,2.5);
  const bodyMat = new THREE.MeshStandardMaterial({color:0xff0000});
  const body = new THREE.Mesh(bodyGeo,bodyMat);
  body.position.y=0.35;
  carGroup.add(body);

  const roofGeo = new THREE.BoxGeometry(0.9,0.4,1.2);
  const roofMat = new THREE.MeshStandardMaterial({color:0x4444ff, transparent:true, opacity:0.6});
  const roof = new THREE.Mesh(roofGeo,roofMat);
  roof.position.y=0.8;
  roof.position.z=-0.2;
  carGroup.add(roof);

  // rodas
  function createWheel(x,z){
    const wheelGeo=new THREE.CylinderGeometry(0.25,0.25,0.2,16);
    const wheelMat=new THREE.MeshStandardMaterial({color:0x000000});
    const wheel=new THREE.Mesh(wheelGeo,wheelMat);
    wheel.rotation.z=Math.PI/2;
    wheel.position.set(x,0.15,z);
    carGroup.add(wheel);
  }
  createWheel(0.5,0.8);
  createWheel(-0.5,0.8);
  createWheel(0.5,-0.8);
  createWheel(-0.5,-0.8);

  scene.add(carGroup);

  // Obst√°culos
  let obstacles = [];
  function createObstacle() {
    let type = Math.random();
    let obstacle;
    if (type<0.33){ // cone
      const coneGeo = new THREE.ConeGeometry(0.4,1,16);
      const coneMat = new THREE.MeshStandardMaterial({color:0xff6600});
      obstacle = new THREE.Mesh(coneGeo,coneMat);
      obstacle.position.y=0.5;
      obstacle.userData = {type:"cone"};
    } else if (type<0.66){ // barril
      const barrelGeo = new THREE.CylinderGeometry(0.4,0.4,1,16);
      const barrelMat = new THREE.MeshStandardMaterial({color:0x996633});
      obstacle = new THREE.Mesh(barrelGeo,barrelMat);
      obstacle.position.y=0.5;
      obstacle.userData = {type:"barrel"};
    } else { // po√ßa de √≥leo
      const oilGeo = new THREE.CircleGeometry(0.8, 32);
      const oilMat = new THREE.MeshStandardMaterial({color:0x000000, metalness:0.8, roughness:0.2});
      obstacle = new THREE.Mesh(oilGeo, oilMat);
      obstacle.rotation.x = -Math.PI/2;
      obstacle.position.y=0.01;
      obstacle.userData = {type:"oil"};
    }
    obstacle.position.set((Math.random()*6)-3,obstacle.position.y,-100);
    scene.add(obstacle);
    obstacles.push(obstacle);
  }
  // Obst√°culos mais pr√≥ximos: spawn mais r√°pido
  setInterval(createObstacle, 1000);

  // √Årvores
  let trees=[];
  function createTree(x,z){
    const trunkGeo = new THREE.CylinderGeometry(0.1,0.1,1);
    const trunkMat = new THREE.MeshStandardMaterial({color:0x8B4513});
    const trunk = new THREE.Mesh(trunkGeo,trunkMat);
    const topGeo = new THREE.SphereGeometry(0.5+Math.random()*0.8,8,8);
    const topMat = new THREE.MeshStandardMaterial({color:0x006400});
    const top = new THREE.Mesh(topGeo,topMat);
    const offsetX=x+(Math.random()*6-3);
    trunk.position.set(offsetX,0.5,z);
    top.position.set(offsetX,1.2,z);
    scene.add(trunk); scene.add(top);
    trees.push({trunk,top});
  }
  for(let i=0;i<80;i++){
    createTree(-10, -i*8);
    createTree(10, -i*8);
  }

  // Pr√©dios
  let buildings=[];
  function createBuilding(x,z){
    const width = 2+Math.random()*3;
    const height = 4+Math.random()*10;
    const depth = 2+Math.random()*3;
    const buildingGeo = new THREE.BoxGeometry(width,height,depth);
    const buildingMat = new THREE.MeshStandardMaterial({color:0x999999});
    const building = new THREE.Mesh(buildingGeo,buildingMat);
    building.position.set(x,height/2,z);
    scene.add(building);
    buildings.push(building);
  }
  for(let i=0;i<40;i++){
    createBuilding(-30,-i*15);
    createBuilding(30,-i*15);
  }

  // Nuvens
  let clouds=[];
  function createCloud(x,z){
    const group=new THREE.Group();
    for(let i=0;i<3;i++){
      const geo=new THREE.SphereGeometry(Math.random()*1+1,8,8);
      const mat=new THREE.MeshStandardMaterial({color:0xffffff});
      const sphere=new THREE.Mesh(geo,mat);
      sphere.position.set(i*1.5,0,Math.random()*1);
      group.add(sphere);
    }
    group.position.set(x,8,z);
    scene.add(group);
    clouds.push(group);
  }
  for(let i=0;i<10;i++){
    createCloud(Math.random()*40-20, -i*30);
  }

  // Controle e movimento
  let carSpeed=1; 
  let keys={};
  document.addEventListener("keydown",(e)=>{keys[e.key]=true;});
  document.addEventListener("keyup",(e)=>{keys[e.key]=false;});

  let targetX = 0;
  let slipTimer = 0; // derrapagem

  function animate(){
    requestAnimationFrame(animate);

    // derrapagem se estiver em √≥leo
    if (slipTimer>0){
      slipTimer--;
      // mexer o targetX aleatoriamente para simular deslize
      targetX += (Math.random()-0.5)*0.3;
    } else {
      // definir alvo conforme teclas
      if(keys["ArrowLeft"]) targetX = Math.max(targetX - 0.2, -4);
      if(keys["ArrowRight"]) targetX = Math.min(targetX + 0.2, 4);
    }

    // suavizar movimento lateral
    carGroup.position.x += (targetX - carGroup.position.x) * 0.1;

    // inclinar o carro
    const tilt = (targetX - carGroup.position.x) * -0.1;
    carGroup.rotation.z = tilt;

    // obst√°culos
    for(let i=0;i<obstacles.length;i++){
      obstacles[i].position.z+=carSpeed;
      if(obstacles[i].position.z>20){
        scene.remove(obstacles[i]);
        obstacles.splice(i,1); i--;
      } else {
        if(obstacles[i] &&
           Math.abs(carGroup.position.x - obstacles[i].position.x) < 1.2 &&
           Math.abs(carGroup.position.z - obstacles[i].position.z) < 1.5){
          if (obstacles[i].userData.type==="oil"){
            slipTimer=60; // 1 seg derrapando
            scene.remove(obstacles[i]);
            obstacles.splice(i,1); i--;
          } else {
            alert("üí• Bateu! Fim de jogo");
            window.location.reload();
          }
        }
      }
    }

    // √°rvores
    for(let t=0;t<trees.length;t++){
      trees[t].trunk.position.z+=carSpeed;
      trees[t].top.position.z+=carSpeed;
      if(trees[t].trunk.position.z>20){
        trees[t].trunk.position.z-=500;
        trees[t].top.position.z-=500;
      }
    }

    // pr√©dios
    for(let b=0;b<buildings.length;b++){
      buildings[b].position.z+=carSpeed;
      if(buildings[b].position.z>50){
        buildings[b].position.z-=600;
      }
    }

    // faixa
    for (let l=0;l<laneMarks.length;l++){
      laneMarks[l].position.z+=carSpeed;
      if(laneMarks[l].position.z>20){
        laneMarks[l].position.z-=600;
      }
    }

    // nuvens
    for(let c=0;c<clouds.length;c++){
      clouds[c].position.z+=0.05;
      if(clouds[c].position.z>20){
        clouds[c].position.z-=300;
      }
    }

    renderer.render(scene,camera);
  }

  animate();

  window.addEventListener("resize",()=>{
    camera.aspect=window.innerWidth/window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth,window.innerHeight);
  });
</script>
</body>
</html>
